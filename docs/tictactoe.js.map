{
  "version": 3,
  "sources": ["../src/index.ts", "../src/games.ts", "../web/src/tictactoe.ts"],
  "sourcesContent": ["/**\n * Modern TypeScript implementation of Monte Carlo Tree Search (MCTS)\n * Clone game once per simulation, then apply moves forward.\n */\n\nexport class RandomSelection<T> {\n  constructor(public readonly array: readonly T[]) {}\n}\n\nexport interface Game<TMove = unknown, TPlayer = unknown> {\n  getPossibleMoves(): readonly TMove[] | RandomSelection<TMove>;\n  performMove(move: TMove): void;\n  getCurrentPlayer(): TPlayer;\n  getWinner(): TPlayer | null;\n  clone(): Game<TMove, TPlayer>;\n}\n\nexport type PlayerScore = Record<string, number>;\n\n// Tree node info for visualization\nexport interface TreeNodeInfo<TMove> {\n  move: TMove | null;\n  visits: number;\n  wins: PlayerScore;\n  winRate: number;\n  children: TreeNodeInfo<TMove>[];\n}\n\nclass Node<TMove, TPlayer> {\n  public wins: PlayerScore = {};\n  public visits = 0;\n  public children: Node<TMove, TPlayer>[] | null = null;\n  public randomNode = false;\n\n  constructor(\n    public readonly parent: Node<TMove, TPlayer> | null,\n    public readonly move: TMove | null,\n    private readonly mcts: MCTS<TMove, TPlayer>\n  ) {}\n\n  public getUCB1(player: TPlayer): number {\n    // Always visit unvisited nodes first\n    if (this.visits === 0) {\n      return Number.POSITIVE_INFINITY;\n    }\n    if (this.parent === null) {\n      return 0;\n    }\n\n    const wins = this.wins[String(player)] ?? 0;\n    const scorePerVisit = wins / this.visits;\n\n    // UCB1 formula: exploitation + exploration\n    // See https://en.wikipedia.org/wiki/Monte_Carlo_tree_search#Exploration_and_exploitation\n    return scorePerVisit + Math.sqrt((2 * Math.log(this.parent.visits)) / this.visits);\n  }\n\n  public getChildren(game: Game<TMove, TPlayer>): Node<TMove, TPlayer>[] {\n    if (this.children === null) {\n      const movesResult = game.getPossibleMoves();\n      let moves: readonly TMove[];\n\n      if (movesResult instanceof RandomSelection) {\n        moves = movesResult.array;\n        this.randomNode = true;\n      } else {\n        moves = movesResult;\n      }\n\n      this.children = moves.map((move) => new Node<TMove, TPlayer>(this, move, this.mcts));\n    }\n    return this.children;\n  }\n\n  public nextMove(game: Game<TMove, TPlayer>): Node<TMove, TPlayer> {\n    const children = this.getChildren(game);\n\n    if (children.length === 0) {\n      throw new Error('Cannot get next move from a node with no children');\n    }\n\n    // Shuffle to randomize equal nodes\n    const shuffled = this.shuffle([...children]);\n\n    if (this.randomNode) {\n      const last = shuffled[shuffled.length - 1];\n      if (last === undefined) {\n        throw new Error('No children available for random selection');\n      }\n      return last;\n    }\n\n    // Sort by UCB1 score and pick the best\n    shuffled.sort((a, b) => this.mcts.compareNodes(a, b, game));\n    const best = shuffled[shuffled.length - 1];\n    if (best === undefined) {\n      throw new Error('No children available after sorting');\n    }\n    return best;\n  }\n\n  private shuffle<T>(array: T[]): T[] {\n    // Fisher-Yates shuffle\n    for (let i = array.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      const temp = array[i];\n      const other = array[j];\n      if (temp !== undefined && other !== undefined) {\n        array[i] = other;\n        array[j] = temp;\n      }\n    }\n    return array;\n  }\n\n  // Export tree structure for visualization\n  public toTreeInfo(player: TPlayer, maxDepth: number): TreeNodeInfo<TMove> {\n    const playerWins = this.wins[String(player)] ?? 0;\n    const winRate = this.visits > 0 ? playerWins / this.visits : 0;\n\n    let childrenInfo: TreeNodeInfo<TMove>[] = [];\n    if (maxDepth > 0 && this.children) {\n      childrenInfo = this.children\n        .filter((c) => c.visits > 0)\n        .sort((a, b) => b.visits - a.visits)\n        .slice(0, 10) // Limit to top 10 children for performance\n        .map((c) => c.toTreeInfo(player, maxDepth - 1));\n    }\n\n    return {\n      move: this.move,\n      visits: this.visits,\n      wins: { ...this.wins },\n      winRate,\n      children: childrenInfo,\n    };\n  }\n}\n\nexport class MCTS<TMove = unknown, TPlayer = unknown> {\n  private readonly rootNode: Node<TMove, TPlayer>;\n  private readonly rounds: number;\n\n  constructor(\n    private readonly game: Game<TMove, TPlayer>,\n    rounds?: number\n  ) {\n    this.rounds = rounds ?? 1000;\n    this.rootNode = new Node<TMove, TPlayer>(null, null, this);\n  }\n\n  public selectMove(): TMove {\n    for (let round = 0; round < this.rounds; round++) {\n      this.runSimulation();\n    }\n\n    const children = this.rootNode.getChildren(this.game);\n    if (children.length === 0) {\n      throw new Error('No possible moves available');\n    }\n\n    // Select the child with the most visits\n    let bestChild = children[0];\n    if (bestChild === undefined) {\n      throw new Error('No children available');\n    }\n\n    for (const child of children) {\n      if (child.visits > bestChild.visits) {\n        bestChild = child;\n      }\n    }\n\n    if (bestChild.move === null) {\n      throw new Error('Best child has null move');\n    }\n\n    return bestChild.move;\n  }\n\n  public getStats(): { move: TMove; visits: number; wins: PlayerScore }[] {\n    const children = this.rootNode.getChildren(this.game);\n    return children.map((child) => {\n      if (child.move === null) {\n        throw new Error('Child node has null move');\n      }\n      return {\n        move: child.move,\n        visits: child.visits,\n        wins: { ...child.wins },\n      };\n    });\n  }\n\n  // Run a batch of simulations (for incremental visualization)\n  public runSimulations(count: number): void {\n    for (let i = 0; i < count; i++) {\n      this.runSimulation();\n    }\n  }\n\n  // Get current total simulation count\n  public getSimulationCount(): number {\n    return this.rootNode.visits;\n  }\n\n  // Get tree structure for visualization\n  public getTreeInfo(maxDepth: number = 3): TreeNodeInfo<TMove> {\n    const player = this.game.getCurrentPlayer();\n    return this.rootNode.toTreeInfo(player, maxDepth);\n  }\n\n  // Get the best move without running more simulations\n  public getBestMove(): TMove | null {\n    const children = this.rootNode.children;\n    if (!children || children.length === 0) {\n      return null;\n    }\n\n    let bestChild = children[0];\n    if (!bestChild) {\n      return null;\n    }\n\n    for (const child of children) {\n      if (child.visits > bestChild.visits) {\n        bestChild = child;\n      }\n    }\n\n    return bestChild.move;\n  }\n\n  // Get move statistics for board highlighting\n  public getMoveStats(): { move: TMove; visits: number; wins: PlayerScore; winRate: number }[] {\n    const children = this.rootNode.children;\n    if (!children) {\n      return [];\n    }\n\n    const player = this.game.getCurrentPlayer();\n    return children\n      .filter((child) => child.move !== null && child.visits > 0)\n      .map((child) => {\n        const playerWins = child.wins[String(player)] ?? 0;\n        return {\n          move: child.move as TMove,\n          visits: child.visits,\n          wins: { ...child.wins },\n          winRate: child.visits > 0 ? playerWins / child.visits : 0,\n        };\n      })\n      .sort((a, b) => b.visits - a.visits);\n  }\n\n  public compareNodes(\n    a: Node<TMove, TPlayer>,\n    b: Node<TMove, TPlayer>,\n    game: Game<TMove, TPlayer>\n  ): number {\n    if (a.parent === null) {\n      return 0;\n    }\n    const currentPlayer = game.getCurrentPlayer();\n    return a.getUCB1(currentPlayer) - b.getUCB1(currentPlayer);\n  }\n\n  private runSimulation(): void {\n    // Clone the game once for this simulation\n    const simGame = this.game.clone();\n\n    const path: Node<TMove, TPlayer>[] = [this.rootNode];\n    let currentNode = this.rootNode;\n    currentNode.visits++;\n\n    // Selection: traverse down the tree using UCB1\n    while (currentNode.getChildren(simGame).length > 0) {\n      currentNode = currentNode.nextMove(simGame);\n      currentNode.visits++;\n      path.push(currentNode);\n\n      // Apply the move to our simulation game\n      if (currentNode.move !== null) {\n        simGame.performMove(currentNode.move);\n      }\n    }\n\n    // Get the winner at this leaf node\n    const winner = simGame.getWinner();\n\n    // Backpropagation: update wins up the tree\n    for (const node of path) {\n      if (winner !== null) {\n        const winnerKey = String(winner);\n        node.wins[winnerKey] = (node.wins[winnerKey] ?? 0) + 1;\n      }\n    }\n\n    // No need to undo - just discard the cloned game\n  }\n}\n", "/**\n * Example game implementations for MCTS testing\n */\n\nimport { type Game, RandomSelection } from './index';\n\nexport class SingleCellGame implements Game<number, number> {\n  private board: (number | null)[] = [null];\n  private readonly currentPlayer = 0;\n\n  public getPossibleMoves(): number[] {\n    if (this.board[0] === null) {\n      return [0];\n    }\n    return [];\n  }\n\n  public performMove(move: number): void {\n    this.board[move] = 0;\n  }\n\n  public getCurrentPlayer(): number {\n    return this.currentPlayer;\n  }\n\n  public getWinner(): number | null {\n    return this.board[0] ?? null;\n  }\n\n  public clone(): SingleCellGame {\n    const cloned = new SingleCellGame();\n    cloned.board = [...this.board];\n    return cloned;\n  }\n}\n\nexport class TwoCellGame implements Game<number, number> {\n  private board: (number | null)[] = [null, null];\n  private currentPlayer = 0;\n\n  public getPossibleMoves(): number[] {\n    const available: number[] = [];\n    for (let i = 0; i < 2; i++) {\n      if (this.board[i] === null) {\n        available.push(i);\n      }\n    }\n    return available;\n  }\n\n  public performMove(move: number): void {\n    this.board[move] = this.currentPlayer;\n    this.currentPlayer = (this.currentPlayer + 1) % 2;\n  }\n\n  public getCurrentPlayer(): number {\n    return this.currentPlayer;\n  }\n\n  public getWinner(): number | null {\n    return this.board[1] ?? null;\n  }\n\n  public clone(): TwoCellGame {\n    const cloned = new TwoCellGame();\n    cloned.board = [...this.board];\n    cloned.currentPlayer = this.currentPlayer;\n    return cloned;\n  }\n}\n\ntype TicTacToePlayer = 'X' | 'O';\ntype TicTacToeMove = readonly [number, number];\n\nexport class TicTacToeGame implements Game<TicTacToeMove, TicTacToePlayer> {\n  public board: (TicTacToePlayer | null)[][] = [\n    [null, null, null],\n    [null, null, null],\n    [null, null, null],\n  ];\n\n  private readonly boardScore: readonly (readonly number[])[] = [\n    [1, 2, 4],\n    [8, 16, 32],\n    [64, 128, 256],\n  ];\n\n  private readonly winningScores = [7, 56, 448, 73, 146, 292, 273, 84];\n  private currentPlayer: TicTacToePlayer = 'X';\n\n  public getPossibleMoves(): TicTacToeMove[] {\n    if (this.getWinner() !== null) {\n      return [];\n    }\n\n    const available: TicTacToeMove[] = [];\n    for (let y = 0; y < 3; y++) {\n      for (let x = 0; x < 3; x++) {\n        if (this.board[y]?.[x] === null) {\n          available.push([y, x]);\n        }\n      }\n    }\n    return available;\n  }\n\n  public performMove(move: TicTacToeMove): void {\n    const [y, x] = move;\n    const row = this.board[y];\n    if (row === undefined) {\n      throw new Error(`Invalid row: ${y}`);\n    }\n    row[x] = this.currentPlayer;\n    this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';\n  }\n\n  public getCurrentPlayer(): TicTacToePlayer {\n    return this.currentPlayer;\n  }\n\n  public getWinner(): TicTacToePlayer | null {\n    const playerScores: Record<TicTacToePlayer, number> = { X: 0, O: 0 };\n\n    for (let y = 0; y < 3; y++) {\n      for (let x = 0; x < 3; x++) {\n        const cell = this.board[y]?.[x];\n        if (cell !== null && cell !== undefined) {\n          const score = this.boardScore[y]?.[x];\n          if (score !== undefined) {\n            playerScores[cell] += score;\n          }\n        }\n      }\n    }\n\n    for (const player of ['X', 'O'] as const) {\n      for (const winningScore of this.winningScores) {\n        if ((winningScore & playerScores[player]) === winningScore) {\n          return player;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  public clone(): TicTacToeGame {\n    const cloned = new TicTacToeGame();\n    cloned.board = this.board.map((row) => [...row]);\n    cloned.currentPlayer = this.currentPlayer;\n    return cloned;\n  }\n}\n\ntype DiceMove = number;\n\nexport class SummingDiceGame implements Game<DiceMove, number> {\n  private readonly currentPlayer = 1;\n  private round = 0;\n  private score = 0;\n  private diceToRoll = 0;\n\n  public getPossibleMoves(): DiceMove[] | RandomSelection<DiceMove> {\n    switch (this.round) {\n      case 0:\n        return [0, 1, 2];\n      case 1:\n        if (this.diceToRoll === 0) {\n          return new RandomSelection([]);\n        }\n        if (this.diceToRoll === 1) {\n          return new RandomSelection([1, 2, 3, 4, 5, 6]);\n        }\n        return new RandomSelection([\n          2, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9,\n          10, 10, 10, 11, 11, 12,\n        ]);\n    }\n    return [];\n  }\n\n  public getCurrentPlayer(): number {\n    return this.currentPlayer;\n  }\n\n  public performMove(move: DiceMove): void {\n    switch (this.round) {\n      case 0:\n        this.diceToRoll = move;\n        break;\n      case 1:\n        this.score += move;\n        break;\n    }\n    this.round++;\n  }\n\n  public getWinner(): number | null {\n    if (this.score > 5) {\n      return 1;\n    }\n    return null;\n  }\n\n  public clone(): SummingDiceGame {\n    const cloned = new SummingDiceGame();\n    cloned.round = this.round;\n    cloned.score = this.score;\n    cloned.diceToRoll = this.diceToRoll;\n    return cloned;\n  }\n}\n\n// Connect 4 / 4 in a Row game implementation\nexport type Connect4Player = 'Red' | 'Yellow';\nexport type Connect4Move = 0 | 1 | 2 | 3 | 4 | 5 | 6;\n\nexport class Connect4Game implements Game<Connect4Move, Connect4Player> {\n  public static readonly ROWS = 6;\n  public static readonly COLS = 7;\n  public static readonly WIN_LENGTH = 4;\n\n  // Board stored as rows from bottom to top, columns left to right\n  public board: (Connect4Player | null)[][] = [];\n  private currentPlayer: Connect4Player = 'Red';\n  private lastMove: { row: number; col: number } | null = null;\n\n  constructor() {\n    this.initBoard();\n  }\n\n  private initBoard(): void {\n    this.board = [];\n    for (let row = 0; row < Connect4Game.ROWS; row++) {\n      this.board.push(new Array(Connect4Game.COLS).fill(null));\n    }\n  }\n\n  public getPossibleMoves(): Connect4Move[] {\n    if (this.getWinner() !== null) {\n      return [];\n    }\n\n    const moves: Connect4Move[] = [];\n    for (let col = 0; col < Connect4Game.COLS; col++) {\n      // Check if the top row of this column is empty\n      const topRow = this.board[Connect4Game.ROWS - 1];\n      if (topRow && topRow[col] === null) {\n        moves.push(col as Connect4Move);\n      }\n    }\n    return moves;\n  }\n\n  public performMove(move: Connect4Move): void {\n    // Find the lowest empty row in this column\n    for (let row = 0; row < Connect4Game.ROWS; row++) {\n      const boardRow = this.board[row];\n      if (boardRow && boardRow[move] === null) {\n        boardRow[move] = this.currentPlayer;\n        this.lastMove = { row, col: move };\n        this.currentPlayer = this.currentPlayer === 'Red' ? 'Yellow' : 'Red';\n        return;\n      }\n    }\n    throw new Error(`Column ${move} is full`);\n  }\n\n  public getCurrentPlayer(): Connect4Player {\n    return this.currentPlayer;\n  }\n\n  public getLastMove(): { row: number; col: number } | null {\n    return this.lastMove;\n  }\n\n  public getWinner(): Connect4Player | null {\n    // Check all directions from each cell\n    const directions: [number, number][] = [\n      [0, 1], // horizontal\n      [1, 0], // vertical\n      [1, 1], // diagonal down-right\n      [1, -1], // diagonal down-left\n    ];\n\n    for (let row = 0; row < Connect4Game.ROWS; row++) {\n      for (let col = 0; col < Connect4Game.COLS; col++) {\n        const cell = this.board[row]?.[col];\n        if (cell === null || cell === undefined) {\n          continue;\n        }\n\n        for (const [dr, dc] of directions) {\n          if (this.checkWinFrom(row, col, dr, dc, cell)) {\n            return cell;\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  private checkWinFrom(\n    startRow: number,\n    startCol: number,\n    dr: number,\n    dc: number,\n    player: Connect4Player\n  ): boolean {\n    for (let i = 0; i < Connect4Game.WIN_LENGTH; i++) {\n      const row = startRow + i * dr;\n      const col = startCol + i * dc;\n      if (\n        row < 0 ||\n        row >= Connect4Game.ROWS ||\n        col < 0 ||\n        col >= Connect4Game.COLS ||\n        this.board[row]?.[col] !== player\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // Get the winning line cells (if any)\n  public getWinningCells(): { row: number; col: number }[] | null {\n    const directions: [number, number][] = [\n      [0, 1],\n      [1, 0],\n      [1, 1],\n      [1, -1],\n    ];\n\n    for (let row = 0; row < Connect4Game.ROWS; row++) {\n      for (let col = 0; col < Connect4Game.COLS; col++) {\n        const cell = this.board[row]?.[col];\n        if (cell === null || cell === undefined) {\n          continue;\n        }\n\n        for (const [dr, dc] of directions) {\n          if (this.checkWinFrom(row, col, dr, dc, cell)) {\n            const cells: { row: number; col: number }[] = [];\n            for (let i = 0; i < Connect4Game.WIN_LENGTH; i++) {\n              cells.push({ row: row + i * dr, col: col + i * dc });\n            }\n            return cells;\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  public isBoardFull(): boolean {\n    const topRow = this.board[Connect4Game.ROWS - 1];\n    if (!topRow) {\n      return false;\n    }\n    return topRow.every((cell) => cell !== null);\n  }\n\n  public clone(): Connect4Game {\n    const cloned = new Connect4Game();\n    cloned.board = this.board.map((row) => [...row]);\n    cloned.currentPlayer = this.currentPlayer;\n    cloned.lastMove = this.lastMove ? { ...this.lastMove } : null;\n    return cloned;\n  }\n}\n", "import { MCTS, type TreeNodeInfo } from '../../src/index';\nimport { TicTacToeGame } from '../../src/games';\n\ntype TicTacToeMove = readonly [number, number];\n\n// DOM elements\nlet boardEl: HTMLElement;\nlet statusEl: HTMLElement;\nlet simCounterEl: HTMLElement;\nlet treeContainerEl: HTMLElement;\nlet newGameBtn: HTMLElement;\nlet simulationsSelect: HTMLSelectElement;\nlet showThinkingSelect: HTMLSelectElement;\n\n// Game state\nlet game: TicTacToeGame;\nlet isPlayerTurn = true;\nlet gameOver = false;\n\n// Initialize DOM references\nfunction initDOM(): void {\n  boardEl = document.getElementById('board')!;\n  statusEl = document.getElementById('status')!;\n  simCounterEl = document.getElementById('sim-counter')!;\n  treeContainerEl = document.getElementById('tree-container')!;\n  newGameBtn = document.getElementById('new-game')!;\n  simulationsSelect = document.getElementById('simulations') as HTMLSelectElement;\n  showThinkingSelect = document.getElementById('show-thinking') as HTMLSelectElement;\n\n  newGameBtn.addEventListener('click', startNewGame);\n}\n\n// Create the board cells\nfunction renderBoard(): void {\n  boardEl.innerHTML = '';\n  for (let row = 0; row < 3; row++) {\n    for (let col = 0; col < 3; col++) {\n      const cell = document.createElement('div');\n      cell.className = 'tictactoe-cell';\n      cell.dataset.row = String(row);\n      cell.dataset.col = String(col);\n      cell.addEventListener('click', () => handleCellClick(row, col));\n      boardEl.appendChild(cell);\n    }\n  }\n  updateBoardDisplay();\n}\n\n// Update the visual display of the board\nfunction updateBoardDisplay(): void {\n  const cells = boardEl.querySelectorAll('.tictactoe-cell');\n  cells.forEach((cell) => {\n    const cellEl = cell as HTMLElement;\n    const row = parseInt(cellEl.dataset.row!, 10);\n    const col = parseInt(cellEl.dataset.col!, 10);\n    const value = game.board[row]?.[col];\n\n    // Clear previous classes\n    cellEl.classList.remove(\n      'X',\n      'O',\n      'occupied',\n      'disabled',\n      'highlight-strong',\n      'highlight-medium',\n      'highlight-weak',\n      'winner'\n    );\n    cellEl.textContent = '';\n\n    // Remove any visit indicator\n    const indicator = cellEl.querySelector('.visit-indicator');\n    if (indicator) {\n      indicator.remove();\n    }\n\n    if (value) {\n      cellEl.textContent = value;\n      cellEl.classList.add(value, 'occupied');\n    }\n\n    if (gameOver || !isPlayerTurn) {\n      cellEl.classList.add('disabled');\n    }\n  });\n\n  // Highlight winning cells if game is over\n  if (gameOver && game.getWinner()) {\n    highlightWinningCells();\n  }\n}\n\n// Find and highlight winning cells\nfunction highlightWinningCells(): void {\n  const winningLines = [\n    [[0, 0], [0, 1], [0, 2]], // rows\n    [[1, 0], [1, 1], [1, 2]],\n    [[2, 0], [2, 1], [2, 2]],\n    [[0, 0], [1, 0], [2, 0]], // cols\n    [[0, 1], [1, 1], [2, 1]],\n    [[0, 2], [1, 2], [2, 2]],\n    [[0, 0], [1, 1], [2, 2]], // diagonals\n    [[0, 2], [1, 1], [2, 0]],\n  ];\n\n  for (const line of winningLines) {\n    const [a, b, c] = line as [[number, number], [number, number], [number, number]];\n    const valA = game.board[a[0]]?.[a[1]];\n    const valB = game.board[b[0]]?.[b[1]];\n    const valC = game.board[c[0]]?.[c[1]];\n\n    if (valA && valA === valB && valB === valC) {\n      for (const [row, col] of line as [number, number][]) {\n        const cell = boardEl.querySelector(`[data-row=\"${row}\"][data-col=\"${col}\"]`);\n        if (cell) {\n          cell.classList.add('winner');\n        }\n      }\n      break;\n    }\n  }\n}\n\n// Handle player clicking a cell\nfunction handleCellClick(row: number, col: number): void {\n  if (!isPlayerTurn || gameOver) {\n    return;\n  }\n\n  const boardRow = game.board[row];\n  if (!boardRow || boardRow[col] !== null) {\n    return;\n  }\n\n  // Make the move\n  game.performMove([row, col] as TicTacToeMove);\n  updateBoardDisplay();\n\n  // Check for game over\n  const winner = game.getWinner();\n  if (winner) {\n    gameOver = true;\n    setStatus(`<span class=\"player-${winner.toLowerCase()}\">${winner}</span> wins!`);\n    updateBoardDisplay();\n    return;\n  }\n\n  if (game.getPossibleMoves().length === 0) {\n    gameOver = true;\n    setStatus(\"It's a draw!\");\n    return;\n  }\n\n  // AI's turn\n  isPlayerTurn = false;\n  setStatus('AI is thinking...', true);\n\n  // Use setTimeout to allow UI to update before heavy computation\n  setTimeout(doAIMove, 50);\n}\n\n// AI makes a move with visualization\nasync function doAIMove(): Promise<void> {\n  const simulations = parseInt(simulationsSelect.value, 10);\n  const showThinking = showThinkingSelect.value === 'true';\n\n  const mcts = new MCTS(game, simulations);\n\n  if (showThinking) {\n    // Run simulations in batches for visualization\n    const batchSize = Math.min(50, Math.ceil(simulations / 20));\n    let completed = 0;\n\n    while (completed < simulations) {\n      const remaining = simulations - completed;\n      const toRun = Math.min(batchSize, remaining);\n      mcts.runSimulations(toRun);\n      completed += toRun;\n\n      // Update visualization\n      updateSimCounter(completed, simulations);\n      highlightMoves(mcts.getMoveStats());\n      updateTreeVisualization(mcts.getTreeInfo(3));\n\n      // Yield to allow UI updates\n      await new Promise((resolve) => setTimeout(resolve, 10));\n    }\n  } else {\n    // Run all simulations at once\n    mcts.runSimulations(simulations);\n    updateSimCounter(simulations, simulations);\n  }\n\n  // Get the best move\n  const bestMove = mcts.getBestMove() as TicTacToeMove | null;\n  if (!bestMove) {\n    gameOver = true;\n    setStatus(\"It's a draw!\");\n    return;\n  }\n\n  // Clear highlights and make the move\n  clearHighlights();\n  game.performMove(bestMove);\n  updateBoardDisplay();\n\n  // Check for game over\n  const winner = game.getWinner();\n  if (winner) {\n    gameOver = true;\n    setStatus(`<span class=\"player-${winner.toLowerCase()}\">${winner}</span> wins!`);\n    updateBoardDisplay();\n    return;\n  }\n\n  if (game.getPossibleMoves().length === 0) {\n    gameOver = true;\n    setStatus(\"It's a draw!\");\n    return;\n  }\n\n  // Player's turn\n  isPlayerTurn = true;\n  setStatus('Your turn! Click a cell to play.');\n  simCounterEl.textContent = '';\n}\n\n// Highlight cells based on AI evaluation (by visits)\nfunction highlightMoves(stats: { move: TicTacToeMove; visits: number; winRate: number }[]): void {\n  if (stats.length === 0) {\n    return;\n  }\n\n  const maxVisits = Math.max(...stats.map((s) => s.visits));\n  const cells = boardEl.querySelectorAll('.tictactoe-cell');\n\n  cells.forEach((cell) => {\n    const cellEl = cell as HTMLElement;\n    cellEl.classList.remove('highlight-strong', 'highlight-medium', 'highlight-weak');\n\n    // Remove existing indicator\n    const existing = cellEl.querySelector('.visit-indicator');\n    if (existing) {\n      existing.remove();\n    }\n  });\n\n  for (const stat of stats) {\n    const [row, col] = stat.move;\n    const cell = boardEl.querySelector(`[data-row=\"${row}\"][data-col=\"${col}\"]`) as HTMLElement;\n    if (!cell || cell.classList.contains('occupied')) {\n      continue;\n    }\n\n    const ratio = stat.visits / maxVisits;\n    if (ratio > 0.6) {\n      cell.classList.add('highlight-strong');\n    } else if (ratio > 0.2) {\n      cell.classList.add('highlight-medium');\n    } else {\n      cell.classList.add('highlight-weak');\n    }\n\n    // Add visit count indicator\n    const indicator = document.createElement('span');\n    indicator.className = 'visit-indicator';\n    indicator.textContent = String(stat.visits);\n    cell.appendChild(indicator);\n  }\n}\n\n// Clear all highlights\nfunction clearHighlights(): void {\n  const cells = boardEl.querySelectorAll('.tictactoe-cell');\n  cells.forEach((cell) => {\n    cell.classList.remove('highlight-strong', 'highlight-medium', 'highlight-weak');\n    const indicator = cell.querySelector('.visit-indicator');\n    if (indicator) {\n      indicator.remove();\n    }\n  });\n}\n\n// Update the tree visualization (text-based)\nfunction updateTreeVisualization(tree: TreeNodeInfo<TicTacToeMove>): void {\n  const html = renderTreeNode(tree, 0, true);\n  treeContainerEl.innerHTML = html;\n}\n\n// Render a tree node recursively\nfunction renderTreeNode(node: TreeNodeInfo<TicTacToeMove>, depth: number, isRoot: boolean): string {\n  if (depth > 2) {\n    return '';\n  }\n\n  const moveStr = isRoot\n    ? 'Root'\n    : node.move\n      ? `[${node.move[0]}, ${node.move[1]}]`\n      : 'Unknown';\n\n  // Color based on visits relative to siblings\n  const visitClass = depth === 1 ? getVisitClass(node.visits, tree.children) : '';\n\n  let html = `\n    <div class=\"tree-node ${visitClass}\">\n      <span class=\"move\">${moveStr}</span>\n      <span class=\"stats\"> | Visits: ${node.visits}</span>\n      <div class=\"visit-bar\">\n        <div class=\"fill\" style=\"width: ${Math.min(100, (node.visits / Math.max(1, tree.visits)) * 100)}%\"></div>\n      </div>\n    </div>\n  `;\n\n  if (node.children.length > 0 && depth < 2) {\n    html += '<div class=\"tree-level\">';\n    // Sort children by visits and show top ones\n    const sortedChildren = [...node.children].sort((a, b) => b.visits - a.visits).slice(0, 5);\n    for (const child of sortedChildren) {\n      html += renderTreeNode(child, depth + 1, false);\n    }\n    html += '</div>';\n  }\n\n  return html;\n}\n\n// Store tree reference for relative visit calculation\nlet tree: TreeNodeInfo<TicTacToeMove>;\n\n// Get visit class based on relative visits\nfunction getVisitClass(visits: number, siblings: TreeNodeInfo<TicTacToeMove>[]): string {\n  if (siblings.length === 0) {\n    return '';\n  }\n  const maxVisits = Math.max(...siblings.map((s) => s.visits));\n  const ratio = visits / maxVisits;\n  if (ratio > 0.6) {\n    return 'best';\n  }\n  return '';\n}\n\n// Update simulation counter\nfunction updateSimCounter(current: number, total: number): void {\n  simCounterEl.textContent = `Simulations: ${current} / ${total}`;\n}\n\n// Set status message\nfunction setStatus(message: string, thinking = false): void {\n  statusEl.innerHTML = message;\n  statusEl.classList.toggle('thinking', thinking);\n}\n\n// Start a new game\nfunction startNewGame(): void {\n  game = new TicTacToeGame();\n  isPlayerTurn = true;\n  gameOver = false;\n  setStatus('Your turn! Click a cell to play.');\n  simCounterEl.textContent = '';\n  treeContainerEl.innerHTML =\n    '<p style=\"color: var(--text-muted);\">The AI\\'s search tree will appear here when it\\'s thinking...</p>';\n  renderBoard();\n}\n\n// Initialize on load\ndocument.addEventListener('DOMContentLoaded', () => {\n  initDOM();\n  startNewGame();\n});\n"],
  "mappings": "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",
  "names": ["game", "tree"]
}
