{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/games.ts", "../../web/src/fourinarow.ts"],
  "sourcesContent": ["/**\n * Modern TypeScript implementation of Monte Carlo Tree Search (MCTS)\n * Clone game once per simulation, then apply moves forward.\n */\n\nexport class RandomSelection<T> {\n  constructor(public readonly array: readonly T[]) {}\n}\n\nexport interface Game<TMove = unknown, TPlayer = unknown> {\n  getPossibleMoves(): readonly TMove[] | RandomSelection<TMove>;\n  performMove(move: TMove): void;\n  getCurrentPlayer(): TPlayer;\n  getWinner(): TPlayer | null;\n  clone(): Game<TMove, TPlayer>;\n}\n\nexport type PlayerScore = Record<string, number>;\n\n// Tree node info for visualization\nexport interface TreeNodeInfo<TMove> {\n  move: TMove | null;\n  visits: number;\n  wins: PlayerScore;\n  winRate: number;\n  children: TreeNodeInfo<TMove>[];\n}\n\nclass Node<TMove, TPlayer> {\n  public wins: PlayerScore = {};\n  public visits = 0;\n  public children: Node<TMove, TPlayer>[] | null = null;\n  public randomNode = false;\n\n  constructor(\n    public readonly parent: Node<TMove, TPlayer> | null,\n    public readonly move: TMove | null,\n    private readonly mcts: MCTS<TMove, TPlayer>\n  ) {}\n\n  public getUCB1(player: TPlayer): number {\n    // Always visit unvisited nodes first\n    if (this.visits === 0) {\n      return Number.POSITIVE_INFINITY;\n    }\n    if (this.parent === null) {\n      return 0;\n    }\n\n    const wins = this.wins[String(player)] ?? 0;\n    const scorePerVisit = wins / this.visits;\n\n    // UCB1 formula: exploitation + exploration\n    // See https://en.wikipedia.org/wiki/Monte_Carlo_tree_search#Exploration_and_exploitation\n    return scorePerVisit + Math.sqrt((2 * Math.log(this.parent.visits)) / this.visits);\n  }\n\n  public getChildren(game: Game<TMove, TPlayer>): Node<TMove, TPlayer>[] {\n    if (this.children === null) {\n      const movesResult = game.getPossibleMoves();\n      let moves: readonly TMove[];\n\n      if (movesResult instanceof RandomSelection) {\n        moves = movesResult.array;\n        this.randomNode = true;\n      } else {\n        moves = movesResult;\n      }\n\n      this.children = moves.map((move) => new Node<TMove, TPlayer>(this, move, this.mcts));\n    }\n    return this.children;\n  }\n\n  public nextMove(game: Game<TMove, TPlayer>): Node<TMove, TPlayer> {\n    const children = this.getChildren(game);\n\n    if (children.length === 0) {\n      throw new Error('Cannot get next move from a node with no children');\n    }\n\n    // Shuffle to randomize equal nodes\n    const shuffled = this.shuffle([...children]);\n\n    if (this.randomNode) {\n      const last = shuffled[shuffled.length - 1];\n      if (last === undefined) {\n        throw new Error('No children available for random selection');\n      }\n      return last;\n    }\n\n    // Sort by UCB1 score and pick the best\n    shuffled.sort((a, b) => this.mcts.compareNodes(a, b, game));\n    const best = shuffled[shuffled.length - 1];\n    if (best === undefined) {\n      throw new Error('No children available after sorting');\n    }\n    return best;\n  }\n\n  private shuffle<T>(array: T[]): T[] {\n    // Fisher-Yates shuffle\n    for (let i = array.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      const temp = array[i];\n      const other = array[j];\n      if (temp !== undefined && other !== undefined) {\n        array[i] = other;\n        array[j] = temp;\n      }\n    }\n    return array;\n  }\n\n  // Export tree structure for visualization\n  public toTreeInfo(player: TPlayer, maxDepth: number): TreeNodeInfo<TMove> {\n    const playerWins = this.wins[String(player)] ?? 0;\n    const winRate = this.visits > 0 ? playerWins / this.visits : 0;\n\n    let childrenInfo: TreeNodeInfo<TMove>[] = [];\n    if (maxDepth > 0 && this.children) {\n      childrenInfo = this.children\n        .filter((c) => c.visits > 0)\n        .sort((a, b) => b.visits - a.visits)\n        .slice(0, 10) // Limit to top 10 children for performance\n        .map((c) => c.toTreeInfo(player, maxDepth - 1));\n    }\n\n    return {\n      move: this.move,\n      visits: this.visits,\n      wins: { ...this.wins },\n      winRate,\n      children: childrenInfo,\n    };\n  }\n}\n\nexport class MCTS<TMove = unknown, TPlayer = unknown> {\n  private readonly rootNode: Node<TMove, TPlayer>;\n  private readonly rounds: number;\n\n  constructor(\n    private readonly game: Game<TMove, TPlayer>,\n    rounds?: number\n  ) {\n    this.rounds = rounds ?? 1000;\n    this.rootNode = new Node<TMove, TPlayer>(null, null, this);\n  }\n\n  public selectMove(): TMove {\n    for (let round = 0; round < this.rounds; round++) {\n      this.runSimulation();\n    }\n\n    const children = this.rootNode.getChildren(this.game);\n    if (children.length === 0) {\n      throw new Error('No possible moves available');\n    }\n\n    // Select the child with the most visits\n    let bestChild = children[0];\n    if (bestChild === undefined) {\n      throw new Error('No children available');\n    }\n\n    for (const child of children) {\n      if (child.visits > bestChild.visits) {\n        bestChild = child;\n      }\n    }\n\n    if (bestChild.move === null) {\n      throw new Error('Best child has null move');\n    }\n\n    return bestChild.move;\n  }\n\n  public getStats(): { move: TMove; visits: number; wins: PlayerScore }[] {\n    const children = this.rootNode.getChildren(this.game);\n    return children.map((child) => {\n      if (child.move === null) {\n        throw new Error('Child node has null move');\n      }\n      return {\n        move: child.move,\n        visits: child.visits,\n        wins: { ...child.wins },\n      };\n    });\n  }\n\n  // Run a batch of simulations (for incremental visualization)\n  public runSimulations(count: number): void {\n    for (let i = 0; i < count; i++) {\n      this.runSimulation();\n    }\n  }\n\n  // Get current total simulation count\n  public getSimulationCount(): number {\n    return this.rootNode.visits;\n  }\n\n  // Get tree structure for visualization\n  public getTreeInfo(maxDepth: number = 3): TreeNodeInfo<TMove> {\n    const player = this.game.getCurrentPlayer();\n    return this.rootNode.toTreeInfo(player, maxDepth);\n  }\n\n  // Get the best move without running more simulations\n  public getBestMove(): TMove | null {\n    const children = this.rootNode.children;\n    if (!children || children.length === 0) {\n      return null;\n    }\n\n    let bestChild = children[0];\n    if (!bestChild) {\n      return null;\n    }\n\n    for (const child of children) {\n      if (child.visits > bestChild.visits) {\n        bestChild = child;\n      }\n    }\n\n    return bestChild.move;\n  }\n\n  // Get move statistics for board highlighting\n  public getMoveStats(): { move: TMove; visits: number; wins: PlayerScore; winRate: number }[] {\n    const children = this.rootNode.children;\n    if (!children) {\n      return [];\n    }\n\n    const player = this.game.getCurrentPlayer();\n    return children\n      .filter((child) => child.move !== null && child.visits > 0)\n      .map((child) => {\n        const playerWins = child.wins[String(player)] ?? 0;\n        return {\n          move: child.move as TMove,\n          visits: child.visits,\n          wins: { ...child.wins },\n          winRate: child.visits > 0 ? playerWins / child.visits : 0,\n        };\n      })\n      .sort((a, b) => b.visits - a.visits);\n  }\n\n  public compareNodes(\n    a: Node<TMove, TPlayer>,\n    b: Node<TMove, TPlayer>,\n    game: Game<TMove, TPlayer>\n  ): number {\n    if (a.parent === null) {\n      return 0;\n    }\n    const currentPlayer = game.getCurrentPlayer();\n    return a.getUCB1(currentPlayer) - b.getUCB1(currentPlayer);\n  }\n\n  private runSimulation(): void {\n    // Clone the game once for this simulation\n    const simGame = this.game.clone();\n\n    const path: Node<TMove, TPlayer>[] = [this.rootNode];\n    let currentNode = this.rootNode;\n    currentNode.visits++;\n\n    // Selection: traverse down the tree using UCB1\n    while (currentNode.getChildren(simGame).length > 0) {\n      currentNode = currentNode.nextMove(simGame);\n      currentNode.visits++;\n      path.push(currentNode);\n\n      // Apply the move to our simulation game\n      if (currentNode.move !== null) {\n        simGame.performMove(currentNode.move);\n      }\n    }\n\n    // Get the winner at this leaf node\n    const winner = simGame.getWinner();\n\n    // Backpropagation: update wins up the tree\n    for (const node of path) {\n      if (winner !== null) {\n        const winnerKey = String(winner);\n        node.wins[winnerKey] = (node.wins[winnerKey] ?? 0) + 1;\n      }\n    }\n\n    // No need to undo - just discard the cloned game\n  }\n}\n", "/**\n * Example game implementations for MCTS testing\n */\n\nimport { type Game, RandomSelection } from './index';\n\nexport class SingleCellGame implements Game<number, number> {\n  private board: (number | null)[] = [null];\n  private readonly currentPlayer = 0;\n\n  public getPossibleMoves(): number[] {\n    if (this.board[0] === null) {\n      return [0];\n    }\n    return [];\n  }\n\n  public performMove(move: number): void {\n    this.board[move] = 0;\n  }\n\n  public getCurrentPlayer(): number {\n    return this.currentPlayer;\n  }\n\n  public getWinner(): number | null {\n    return this.board[0] ?? null;\n  }\n\n  public clone(): SingleCellGame {\n    const cloned = new SingleCellGame();\n    cloned.board = [...this.board];\n    return cloned;\n  }\n}\n\nexport class TwoCellGame implements Game<number, number> {\n  private board: (number | null)[] = [null, null];\n  private currentPlayer = 0;\n\n  public getPossibleMoves(): number[] {\n    const available: number[] = [];\n    for (let i = 0; i < 2; i++) {\n      if (this.board[i] === null) {\n        available.push(i);\n      }\n    }\n    return available;\n  }\n\n  public performMove(move: number): void {\n    this.board[move] = this.currentPlayer;\n    this.currentPlayer = (this.currentPlayer + 1) % 2;\n  }\n\n  public getCurrentPlayer(): number {\n    return this.currentPlayer;\n  }\n\n  public getWinner(): number | null {\n    return this.board[1] ?? null;\n  }\n\n  public clone(): TwoCellGame {\n    const cloned = new TwoCellGame();\n    cloned.board = [...this.board];\n    cloned.currentPlayer = this.currentPlayer;\n    return cloned;\n  }\n}\n\ntype TicTacToePlayer = 'X' | 'O';\ntype TicTacToeMove = readonly [number, number];\n\nexport class TicTacToeGame implements Game<TicTacToeMove, TicTacToePlayer> {\n  public board: (TicTacToePlayer | null)[][] = [\n    [null, null, null],\n    [null, null, null],\n    [null, null, null],\n  ];\n\n  private readonly boardScore: readonly (readonly number[])[] = [\n    [1, 2, 4],\n    [8, 16, 32],\n    [64, 128, 256],\n  ];\n\n  private readonly winningScores = [7, 56, 448, 73, 146, 292, 273, 84];\n  private currentPlayer: TicTacToePlayer = 'X';\n\n  public getPossibleMoves(): TicTacToeMove[] {\n    if (this.getWinner() !== null) {\n      return [];\n    }\n\n    const available: TicTacToeMove[] = [];\n    for (let y = 0; y < 3; y++) {\n      for (let x = 0; x < 3; x++) {\n        if (this.board[y]?.[x] === null) {\n          available.push([y, x]);\n        }\n      }\n    }\n    return available;\n  }\n\n  public performMove(move: TicTacToeMove): void {\n    const [y, x] = move;\n    const row = this.board[y];\n    if (row === undefined) {\n      throw new Error(`Invalid row: ${y}`);\n    }\n    row[x] = this.currentPlayer;\n    this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';\n  }\n\n  public getCurrentPlayer(): TicTacToePlayer {\n    return this.currentPlayer;\n  }\n\n  public getWinner(): TicTacToePlayer | null {\n    const playerScores: Record<TicTacToePlayer, number> = { X: 0, O: 0 };\n\n    for (let y = 0; y < 3; y++) {\n      for (let x = 0; x < 3; x++) {\n        const cell = this.board[y]?.[x];\n        if (cell !== null && cell !== undefined) {\n          const score = this.boardScore[y]?.[x];\n          if (score !== undefined) {\n            playerScores[cell] += score;\n          }\n        }\n      }\n    }\n\n    for (const player of ['X', 'O'] as const) {\n      for (const winningScore of this.winningScores) {\n        if ((winningScore & playerScores[player]) === winningScore) {\n          return player;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  public clone(): TicTacToeGame {\n    const cloned = new TicTacToeGame();\n    cloned.board = this.board.map((row) => [...row]);\n    cloned.currentPlayer = this.currentPlayer;\n    return cloned;\n  }\n}\n\ntype DiceMove = number;\n\nexport class SummingDiceGame implements Game<DiceMove, number> {\n  private readonly currentPlayer = 1;\n  private round = 0;\n  private score = 0;\n  private diceToRoll = 0;\n\n  public getPossibleMoves(): DiceMove[] | RandomSelection<DiceMove> {\n    switch (this.round) {\n      case 0:\n        return [0, 1, 2];\n      case 1:\n        if (this.diceToRoll === 0) {\n          return new RandomSelection([]);\n        }\n        if (this.diceToRoll === 1) {\n          return new RandomSelection([1, 2, 3, 4, 5, 6]);\n        }\n        return new RandomSelection([\n          2, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9,\n          10, 10, 10, 11, 11, 12,\n        ]);\n    }\n    return [];\n  }\n\n  public getCurrentPlayer(): number {\n    return this.currentPlayer;\n  }\n\n  public performMove(move: DiceMove): void {\n    switch (this.round) {\n      case 0:\n        this.diceToRoll = move;\n        break;\n      case 1:\n        this.score += move;\n        break;\n    }\n    this.round++;\n  }\n\n  public getWinner(): number | null {\n    if (this.score > 5) {\n      return 1;\n    }\n    return null;\n  }\n\n  public clone(): SummingDiceGame {\n    const cloned = new SummingDiceGame();\n    cloned.round = this.round;\n    cloned.score = this.score;\n    cloned.diceToRoll = this.diceToRoll;\n    return cloned;\n  }\n}\n\n// Connect 4 / 4 in a Row game implementation\nexport type Connect4Player = 'Red' | 'Yellow';\nexport type Connect4Move = 0 | 1 | 2 | 3 | 4 | 5 | 6;\n\nexport class Connect4Game implements Game<Connect4Move, Connect4Player> {\n  public static readonly ROWS = 6;\n  public static readonly COLS = 7;\n  public static readonly WIN_LENGTH = 4;\n\n  // Board stored as rows from bottom to top, columns left to right\n  public board: (Connect4Player | null)[][] = [];\n  private currentPlayer: Connect4Player = 'Red';\n  private lastMove: { row: number; col: number } | null = null;\n\n  constructor() {\n    this.initBoard();\n  }\n\n  private initBoard(): void {\n    this.board = [];\n    for (let row = 0; row < Connect4Game.ROWS; row++) {\n      this.board.push(new Array(Connect4Game.COLS).fill(null));\n    }\n  }\n\n  public getPossibleMoves(): Connect4Move[] {\n    if (this.getWinner() !== null) {\n      return [];\n    }\n\n    const moves: Connect4Move[] = [];\n    for (let col = 0; col < Connect4Game.COLS; col++) {\n      // Check if the top row of this column is empty\n      const topRow = this.board[Connect4Game.ROWS - 1];\n      if (topRow && topRow[col] === null) {\n        moves.push(col as Connect4Move);\n      }\n    }\n    return moves;\n  }\n\n  public performMove(move: Connect4Move): void {\n    // Find the lowest empty row in this column\n    for (let row = 0; row < Connect4Game.ROWS; row++) {\n      const boardRow = this.board[row];\n      if (boardRow && boardRow[move] === null) {\n        boardRow[move] = this.currentPlayer;\n        this.lastMove = { row, col: move };\n        this.currentPlayer = this.currentPlayer === 'Red' ? 'Yellow' : 'Red';\n        return;\n      }\n    }\n    throw new Error(`Column ${move} is full`);\n  }\n\n  public getCurrentPlayer(): Connect4Player {\n    return this.currentPlayer;\n  }\n\n  public getLastMove(): { row: number; col: number } | null {\n    return this.lastMove;\n  }\n\n  public getWinner(): Connect4Player | null {\n    // Check all directions from each cell\n    const directions: [number, number][] = [\n      [0, 1], // horizontal\n      [1, 0], // vertical\n      [1, 1], // diagonal down-right\n      [1, -1], // diagonal down-left\n    ];\n\n    for (let row = 0; row < Connect4Game.ROWS; row++) {\n      for (let col = 0; col < Connect4Game.COLS; col++) {\n        const cell = this.board[row]?.[col];\n        if (cell === null || cell === undefined) {\n          continue;\n        }\n\n        for (const [dr, dc] of directions) {\n          if (this.checkWinFrom(row, col, dr, dc, cell)) {\n            return cell;\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  private checkWinFrom(\n    startRow: number,\n    startCol: number,\n    dr: number,\n    dc: number,\n    player: Connect4Player\n  ): boolean {\n    for (let i = 0; i < Connect4Game.WIN_LENGTH; i++) {\n      const row = startRow + i * dr;\n      const col = startCol + i * dc;\n      if (\n        row < 0 ||\n        row >= Connect4Game.ROWS ||\n        col < 0 ||\n        col >= Connect4Game.COLS ||\n        this.board[row]?.[col] !== player\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // Get the winning line cells (if any)\n  public getWinningCells(): { row: number; col: number }[] | null {\n    const directions: [number, number][] = [\n      [0, 1],\n      [1, 0],\n      [1, 1],\n      [1, -1],\n    ];\n\n    for (let row = 0; row < Connect4Game.ROWS; row++) {\n      for (let col = 0; col < Connect4Game.COLS; col++) {\n        const cell = this.board[row]?.[col];\n        if (cell === null || cell === undefined) {\n          continue;\n        }\n\n        for (const [dr, dc] of directions) {\n          if (this.checkWinFrom(row, col, dr, dc, cell)) {\n            const cells: { row: number; col: number }[] = [];\n            for (let i = 0; i < Connect4Game.WIN_LENGTH; i++) {\n              cells.push({ row: row + i * dr, col: col + i * dc });\n            }\n            return cells;\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  public isBoardFull(): boolean {\n    const topRow = this.board[Connect4Game.ROWS - 1];\n    if (!topRow) {\n      return false;\n    }\n    return topRow.every((cell) => cell !== null);\n  }\n\n  public clone(): Connect4Game {\n    const cloned = new Connect4Game();\n    cloned.board = this.board.map((row) => [...row]);\n    cloned.currentPlayer = this.currentPlayer;\n    cloned.lastMove = this.lastMove ? { ...this.lastMove } : null;\n    return cloned;\n  }\n}\n", "import { MCTS, type TreeNodeInfo } from '../../src/index';\nimport { Connect4Game, type Connect4Move } from '../../src/games';\n\n// DOM elements\nlet boardEl: HTMLElement;\nlet columnIndicatorsEl: HTMLElement;\nlet statusEl: HTMLElement;\nlet simCounterEl: HTMLElement;\nlet treeContainerEl: HTMLElement;\nlet newGameBtn: HTMLElement;\nlet simulationsSelect: HTMLSelectElement;\nlet showThinkingSelect: HTMLSelectElement;\n\n// Game state\nlet game: Connect4Game;\nlet isPlayerTurn = true;\nlet gameOver = false;\n\n// Initialize DOM references\nfunction initDOM(): void {\n  boardEl = document.getElementById('board')!;\n  columnIndicatorsEl = document.getElementById('column-indicators')!;\n  statusEl = document.getElementById('status')!;\n  simCounterEl = document.getElementById('sim-counter')!;\n  treeContainerEl = document.getElementById('tree-container')!;\n  newGameBtn = document.getElementById('new-game')!;\n  simulationsSelect = document.getElementById('simulations') as HTMLSelectElement;\n  showThinkingSelect = document.getElementById('show-thinking') as HTMLSelectElement;\n\n  newGameBtn.addEventListener('click', startNewGame);\n}\n\n// Create the board cells\nfunction renderBoard(): void {\n  // Create column indicators\n  columnIndicatorsEl.innerHTML = '';\n  for (let col = 0; col < Connect4Game.COLS; col++) {\n    const indicator = document.createElement('div');\n    indicator.className = 'column-indicator';\n    indicator.dataset.col = String(col);\n    columnIndicatorsEl.appendChild(indicator);\n  }\n\n  // Create board cells (from top to bottom visually, but stored bottom to top)\n  boardEl.innerHTML = '';\n  for (let row = Connect4Game.ROWS - 1; row >= 0; row--) {\n    for (let col = 0; col < Connect4Game.COLS; col++) {\n      const cell = document.createElement('div');\n      cell.className = 'connect4-cell';\n      cell.dataset.row = String(row);\n      cell.dataset.col = String(col);\n      cell.addEventListener('click', () => handleCellClick(col));\n      boardEl.appendChild(cell);\n    }\n  }\n  updateBoardDisplay();\n}\n\n// Update the visual display of the board\nfunction updateBoardDisplay(): void {\n  const cells = boardEl.querySelectorAll('.connect4-cell');\n  cells.forEach((cell) => {\n    const cellEl = cell as HTMLElement;\n    const row = parseInt(cellEl.dataset.row!, 10);\n    const col = parseInt(cellEl.dataset.col!, 10);\n    const value = game.board[row]?.[col];\n\n    // Clear previous classes (keep base class)\n    cellEl.classList.remove('Red', 'Yellow', 'occupied', 'disabled', 'winner', 'dropping');\n\n    if (value) {\n      cellEl.classList.add(value, 'occupied');\n    }\n\n    if (gameOver || !isPlayerTurn) {\n      cellEl.classList.add('disabled');\n    }\n  });\n\n  // Highlight winning cells if game is over\n  if (gameOver) {\n    const winningCells = game.getWinningCells();\n    if (winningCells) {\n      for (const { row, col } of winningCells) {\n        const cell = boardEl.querySelector(`[data-row=\"${row}\"][data-col=\"${col}\"]`);\n        if (cell) {\n          cell.classList.add('winner');\n        }\n      }\n    }\n  }\n}\n\n// Handle clicking a column\nfunction handleCellClick(col: number): void {\n  if (!isPlayerTurn || gameOver) {\n    return;\n  }\n\n  const possibleMoves = game.getPossibleMoves();\n  if (!possibleMoves.includes(col as Connect4Move)) {\n    return;\n  }\n\n  // Make the move with drop animation\n  const targetRow = findDropRow(col);\n  game.performMove(col as Connect4Move);\n\n  // Add dropping animation to the new piece\n  if (targetRow !== null) {\n    const cell = boardEl.querySelector(`[data-row=\"${targetRow}\"][data-col=\"${col}\"]`);\n    if (cell) {\n      cell.classList.add('dropping');\n      setTimeout(() => cell.classList.remove('dropping'), 400);\n    }\n  }\n\n  updateBoardDisplay();\n\n  // Check for game over\n  const winner = game.getWinner();\n  if (winner) {\n    gameOver = true;\n    setStatus(`<span class=\"player-${winner.toLowerCase()}\">${winner}</span> wins!`);\n    updateBoardDisplay();\n    return;\n  }\n\n  if (game.isBoardFull()) {\n    gameOver = true;\n    setStatus(\"It's a draw!\");\n    return;\n  }\n\n  // AI's turn\n  isPlayerTurn = false;\n  setStatus('AI is thinking...', true);\n\n  // Use setTimeout to allow UI to update before heavy computation\n  setTimeout(doAIMove, 50);\n}\n\n// Find the row where a piece would drop in a column\nfunction findDropRow(col: number): number | null {\n  for (let row = 0; row < Connect4Game.ROWS; row++) {\n    if (game.board[row]?.[col] === null) {\n      return row;\n    }\n  }\n  return null;\n}\n\n// AI makes a move with visualization\nasync function doAIMove(): Promise<void> {\n  const simulations = parseInt(simulationsSelect.value, 10);\n  const showThinking = showThinkingSelect.value === 'true';\n\n  const mcts = new MCTS(game, simulations);\n\n  if (showThinking) {\n    // Run simulations in batches for visualization\n    const batchSize = Math.min(100, Math.ceil(simulations / 15));\n    let completed = 0;\n\n    while (completed < simulations) {\n      const remaining = simulations - completed;\n      const toRun = Math.min(batchSize, remaining);\n      mcts.runSimulations(toRun);\n      completed += toRun;\n\n      // Update visualization\n      updateSimCounter(completed, simulations);\n      highlightColumns(mcts.getMoveStats());\n      updateTreeVisualization(mcts.getTreeInfo(3));\n\n      // Yield to allow UI updates\n      await new Promise((resolve) => setTimeout(resolve, 10));\n    }\n  } else {\n    // Run all simulations at once\n    mcts.runSimulations(simulations);\n    updateSimCounter(simulations, simulations);\n  }\n\n  // Get the best move\n  const bestMove = mcts.getBestMove() as Connect4Move | null;\n  if (bestMove === null) {\n    gameOver = true;\n    setStatus(\"It's a draw!\");\n    return;\n  }\n\n  // Clear highlights and make the move\n  clearHighlights();\n\n  // Find target row for animation\n  const targetRow = findDropRow(bestMove);\n  game.performMove(bestMove);\n\n  // Add dropping animation\n  if (targetRow !== null) {\n    const cell = boardEl.querySelector(`[data-row=\"${targetRow}\"][data-col=\"${bestMove}\"]`);\n    if (cell) {\n      cell.classList.add('dropping');\n      setTimeout(() => cell.classList.remove('dropping'), 400);\n    }\n  }\n\n  updateBoardDisplay();\n\n  // Check for game over\n  const winner = game.getWinner();\n  if (winner) {\n    gameOver = true;\n    setStatus(`<span class=\"player-${winner.toLowerCase()}\">${winner}</span> wins!`);\n    updateBoardDisplay();\n    return;\n  }\n\n  if (game.isBoardFull()) {\n    gameOver = true;\n    setStatus(\"It's a draw!\");\n    return;\n  }\n\n  // Player's turn\n  isPlayerTurn = true;\n  setStatus('Your turn! Click a column to drop a piece.');\n  simCounterEl.textContent = '';\n}\n\n// Highlight column indicators based on AI evaluation (by visits)\nfunction highlightColumns(stats: { move: Connect4Move; visits: number; winRate: number }[]): void {\n  if (stats.length === 0) {\n    return;\n  }\n\n  const maxVisits = Math.max(...stats.map((s) => s.visits));\n\n  // Clear existing highlights\n  const indicators = columnIndicatorsEl.querySelectorAll('.column-indicator');\n  indicators.forEach((ind) => {\n    ind.classList.remove('highlight-strong', 'highlight-medium', 'highlight-weak');\n  });\n\n  for (const stat of stats) {\n    const indicator = columnIndicatorsEl.querySelector(`[data-col=\"${stat.move}\"]`);\n    if (!indicator) {\n      continue;\n    }\n\n    const ratio = stat.visits / maxVisits;\n    if (ratio > 0.6) {\n      indicator.classList.add('highlight-strong');\n    } else if (ratio > 0.2) {\n      indicator.classList.add('highlight-medium');\n    } else {\n      indicator.classList.add('highlight-weak');\n    }\n  }\n}\n\n// Clear all highlights\nfunction clearHighlights(): void {\n  const indicators = columnIndicatorsEl.querySelectorAll('.column-indicator');\n  indicators.forEach((ind) => {\n    ind.classList.remove('highlight-strong', 'highlight-medium', 'highlight-weak');\n  });\n}\n\n// Update the tree visualization (text-based)\nfunction updateTreeVisualization(treeData: TreeNodeInfo<Connect4Move>): void {\n  const html = renderTreeNode(treeData, 0, true, treeData);\n  treeContainerEl.innerHTML = html;\n}\n\n// Render a tree node recursively\nfunction renderTreeNode(node: TreeNodeInfo<Connect4Move>, depth: number, isRoot: boolean, rootTree: TreeNodeInfo<Connect4Move>): string {\n  if (depth > 2) {\n    return '';\n  }\n\n  const moveStr = isRoot ? 'Root' : node.move !== null ? `Column ${node.move + 1}` : 'Unknown';\n\n  // Color based on visits relative to siblings\n  const visitClass = depth === 1 ? getVisitClass(node.visits, rootTree.children) : '';\n\n  let html = `\n    <div class=\"tree-node ${visitClass}\">\n      <span class=\"move\">${moveStr}</span>\n      <span class=\"stats\"> | Visits: ${node.visits}</span>\n      <div class=\"visit-bar\">\n        <div class=\"fill\" style=\"width: ${Math.min(100, (node.visits / Math.max(1, rootTree.visits)) * 100)}%\"></div>\n      </div>\n    </div>\n  `;\n\n  if (node.children.length > 0 && depth < 2) {\n    html += '<div class=\"tree-level\">';\n    // Sort children by visits and show top ones\n    const sortedChildren = [...node.children].sort((a, b) => b.visits - a.visits).slice(0, 5);\n    for (const child of sortedChildren) {\n      html += renderTreeNode(child, depth + 1, false, rootTree);\n    }\n    html += '</div>';\n  }\n\n  return html;\n}\n\n// Get visit class based on relative visits\nfunction getVisitClass(visits: number, siblings: TreeNodeInfo<Connect4Move>[]): string {\n  if (siblings.length === 0) {\n    return '';\n  }\n  const maxVisits = Math.max(...siblings.map((s) => s.visits));\n  const ratio = visits / maxVisits;\n  if (ratio > 0.6) {\n    return 'best';\n  }\n  return '';\n}\n\n// Update simulation counter\nfunction updateSimCounter(current: number, total: number): void {\n  simCounterEl.textContent = `Simulations: ${current} / ${total}`;\n}\n\n// Set status message\nfunction setStatus(message: string, thinking = false): void {\n  statusEl.innerHTML = message;\n  statusEl.classList.toggle('thinking', thinking);\n}\n\n// Start a new game\nfunction startNewGame(): void {\n  game = new Connect4Game();\n  isPlayerTurn = true;\n  gameOver = false;\n  setStatus('Your turn! Click a column to drop a piece.');\n  simCounterEl.textContent = '';\n  treeContainerEl.innerHTML =\n    '<p style=\"color: var(--text-muted);\">The AI\\'s search tree will appear here when it\\'s thinking...</p>';\n  renderBoard();\n}\n\n// Initialize on load\ndocument.addEventListener('DOMContentLoaded', () => {\n  initDOM();\n  startNewGame();\n});\n"],
  "mappings": "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",
  "names": ["game"]
}
